# Conteúdo da Prova 2

Esse documento é um resumo do conteúdo que corresponde à prova 2 da disciplina
de Algoritmos e Teoria de Grafos.

Sumário:

1.  [Busca em Grafos](#busca-em-grafos)
    1.  [Algoritmo Genérico de Busca](#algoritmo-genérico-de-busca)
    1.  [Busca em Largura](#busca-em-largura)
    1.  [Algoritmo de Jarnik-Prim](#algoritmo-de-jarnik-prim)
    1.  [Algoritmo de Dijkstra](#algoritmo-de-dijkstra)
    1.  [Busca em Profundidade](#busca-em-profundidade)
    1.  [Buscas e Grafos Direcionados](#busca-e-grafos-direcionados)
1.  [Emparelhamento](#emparelhamento)
1.  [Algoritmo de Kruskal](#algoritmo-de-krustal)
1.  [Planaridade](#planaridade)
1.  [Algoritmo de Teste de Planaridade](#algoritmo-de-teste-de-planaridade)
1.  [Referências](#referências)
1.  [Veja também](#veja-também)

## Busca em Grafos

Algoritmos que processam cada vértice e cada aresta de um grafo.

Normalmente, nesses algoritmos os vértices possuem 3 estados:

*   $V_2$

    Vértices cujas arestas já foram processadas pelo algoritmo.
    
*   $V_1$

    Vértices cujas algumas arestas foram processadas pelo algoritmo, mas não
    todas.

*   $V_0$

    Vértices que ainda não foram processados pelo algoritmo.

### Algoritmo Genérico de Busca

```
Busca(G)
    # Inicialmente, todos os vértices estão no estado 0
    Para v em V(G)
        v.estado = 0

    # Executa um outro algoritmo para cada vértice no estado 0
    Para v em V(G)
        Se v.estado == 0
            Busca(G, v)
```

```
# Essa função mapeia um componente inteiro
Busca(G, r)
    V1 = vazio
    processe r
    r.pai = vazio
    acrescente r a V1
    r.estado = 1
    Enquanto V1 != vazio
        v = vertice em V1
        Se não há "próximo" vértice na vizinhança de v em G
            retire v de V1
            v.estado = 2
        Senão
            w = "próximo" vértice da vizinhança de v em G
            Se w.estado != 0
                Se {v, w} não foi processado
                    processe {v, w}
            Senão
                processe {v, w}
                processe w
                w.pai = v
                acrescente w a V1
                w.estado = 1
```

#### Teorema 50

$G_r$: componente de G que contém o vértice r

Busca(G, r) devolve árvore enraizada (T, r) geradora de $G_r$

processa todos os vértices e arestas de $G_r$

$2 * |E(G_r)| + |V(G_r)|$

Diferentes árvores geradoras de $G_r$ são construídas, dependendo dos vértices
escolhidaos em cada iteração.

#### Componentes Conexos

Uma aplicação do Algoritmo Genérico de Busca.

Ideia: marca todos os vértices do componente com um mesmo número.

```
Componentes(G)
    Para cada v em V(G)
        v.estado = 0
        v.componente = 0
    c = 0
    Para cada v em V(G)
        Se v.estado == 0
            v.componente = ++c
            Componente(G, v)
```

```
Componente(G, r)
    V = vazio
    acrescente r a V
    r.estado = 1
    Enquanto V != vazio
        retire um vértice v de V
        Para cada w da vizinhança de v em G
            Se w.estado == 0
                w.componente = v.componente
                acrescente w a V
                w.estado = 1
        v.estado = 2
```

Complexidade: $\Theta(n + m)$.

### Busca em Largura

Uma busca em que os vértices são processados em ordem não decrescente de
distância de r (raíz).

Em outras palavras, todos os vértices a distância d de r são processados antes
de todos os vértices a distância d + 1 de r.

```
BuscaLargura(G)
    Para v em V(G)
        v.estado = 0
    Para v em V(G)
        Se v.estado == 0
            BuscaLargura(G, v)
```

```
BuscaLargura(G, r)
    V = fila vazia
    processe r
    r.pai = vazio
    enfile r em V
    r.estado = 1
    Enquanto V não está vazia
        desenfile um vértice v de V
        Para cada w da vizinhança de v em G
            Se w.estado == 1
                processe {v, w} # aresta fora da árvore
            Senão, se w.estado == 0
                processe w
                processw {v, w} # aresta da árvore
                w.pai = v
                enfile w em V
                w.estado = 1
        v.estado = 2
```

#### Teorema

Se F é a floresta direcionada resultante de uma busca em largura sobre um grafo
G, então toda aresta fora de F é cruzada com relação a F.

#### Teorema 53

Se T é a arborescência resultante de uma busca em largura a partir do vértice r
em um grafo conexo G, então $$d_T(r, v) = d_g(r, v), \text{ para todo } v \in V(G)$$

#### Corolário 54

Se (T, r) é a árvore enraizada resultante de uma busca em largura em um grafo
conexo G, então rTv é um caminho mínimo em G para todo v em V(G).

#### Caminhos Minímos

Uma aplicação da busca em largura.

```
CaminhosMinimos(G, r)
    V = fila vazia
    r.dist = 0
    enfile r em V
    r.estado = 1
    Enquanto V != vazio
        desenfile um vértice v de V
        Para cada w da vizinhança de v em G
            Se w.estado == 0
                w.pai = v
                w.dist = w.pai.dist + 1
                enfile w em V
                w.estado = 1
        v.estado = 2
```

#### Árvore de Caminhos Mínimos

É uma árvore enraizada (T, r) onde rTv é um caminho mínimo em G para todo v em
V(G).

Corolário: É possível computar uma árvore de caminhos mínimos geradora de um
grafo conexo com m arestas em tempo $\Theta(m)$.

#### Distâncias e Diâmetro

Corolário: É possível computar as distâncias e os caminhos mínimos entre todos
os pares de vértices de um grafo com n vértices e m arestas em tempo
$\Theta(n.m)$.

Corolário: É possível computar o diâmetro de um grafo conexo com n vértices e m
arestas em tempo $\Theta(n.m)$.

#### Bipartição

Teorema: Se (T, r) é a árvore enraizada resultante de uma busca em largura
sobre um grafo conexo G, então $$|d_g(r, u) - d_g(r, v)| \le 1, \text{ para todo } \{u, v\} \in E(G - T)$$

Teorema: Seja (T, r) a árvore enraizada resultante de uma busca em largura
sobre um grafo conexo G. O grafo G é bipartido se, e somente se, d(r, u) e d(r,
v) tem paridades diferentes para toda aresta {u, v} em E(G - T).

Corolário: É possível decidir se um grafo de n vértices e m arestas é bipartido
e, em caso positivo, computar sua bipartição em tempo $\Theta(n + m)$.

### Algoritmo de Jarnik-Prim

Algoritmo para encontrar uma árvore geradora mínima.

**árvore geradora mínima**: árvore geradora de G de peso mínimo.

```
AGMp(G, w)
    T = grafo vazio
    acrescente um vértice r de G a T
    Enquanto a fronteira de V(T) em G não estiver vazia
        escolha uma aresta e da fronteira de V(T) em G de peso mínimo
        acrescente a aresta e ao grafo T
    Devolva T
```

#### Teorema

Ao inicio de cada iteração, T é subárvore de uma árvore geradora mínima de G.

Demonstração:

1.  T\* := árvore geradora mínima de (G, w)
2.  T' := T\*[V(T)]
3.  última iteração para a qual T e T' coincidem
    1. e := aresta escolhida nesta iteração
    2. e' := aresta do ciclo fundamental de T\* + e na fronteira de V(T) em G
    3. T" := T\* + e - e'
    4. w(e) $\le$ w(e')
    5. w(T") = w(T\* + e - e') = w(T\*) + w(e) - w(e') $\le$ w(T\*)
    6. T" é árvore geradora mínimo (T\* é árvore geradora mínima)
    7. T é subárvore de uma árvore geradora mínima de G (T é subgrafo de T")

#### Corolário 62

AGMp(G, w) devolve uma árvore geradora mínima em (G, w).

#### Algoritmo de Prim

```
AGMp(G, w)
    Para cada v em V(G)
        v.estado = 0
    V = vazio
    r = um vértice de G
    r.pai = vazio
    r.custo = 0
    acrescente r a V
    r.estado = 1
    Enquanto V != vazio
        retire de V um vértice v com v.custo mínimo
        Para cada u em vizinhança de v em G
            Se u.estado == 1
                Se w({u, v}) < u.custo
                    u.pai = v
                    u.custo = w({u, v})
            Senão, se u.estado == 0
                acrescente u a V
                u.estado = 1
                u.pai = v
                u.custo = w({u, v})
        v.estado = 2
```

#### Corolário 63

(G, w): grafo ponderado com n vértices e m arestas.

AGMp(G, w) executa em tempo $\Theta(m.log(n))$

Demonstração:

1.  V: fila de prioridades (|V| $\le$ n)
2.  trecho antes do laço: $\Theta(n)$
3.  cada iteração
    1. retira um elemento v de V: $\Theta(log(n))$
    2. altera o custo de um vizinho u de v: $\Theta(1)$
    3. acrescenta u a V: $\Theta(log(n))$
4.  $\le$ 2m iterações (agregadas entre os laços externo e interno)
5.  tempo de execução total: $\Theta(m.log(n))$

### Algoritmo de Dijkstra

(G, w): grafo ponderado conexo.

**árvore de caminhos mínimos**: árvore enraizada (T, r) geradora de G.

rTv é caminho mínimo em G para todo v em V(G).

O Dijkstra encontra a árvore de caminhos mínimos. Parece o da busca em largura
só que com pesos.

#### Teorema 64

Para todo v em V(G) existe uma árvore de caminhos mínimos enraizada em v.

```
CM(G, w, r)
    T = ({r}, vazio)
    Enquanto a fronteira de V(T) em G != vazio
        escolha uma aresta {x, y} da fronteira V(T) em G tal que d_t(r, x) + w({x, y}) é mínimo
        acrescente o vértice y e a aresta {x, y} a T
    Devolta (T, r)
```

```
CM(G, w)
    Para cada v em V(G)
        v.estado = 0
    V = vazio
    r.custo = 0
    r.estado = 1
    acrescente r a V
    Enquanto V != vazio
        retire de V um vértice v com v.custo mínimo
        Para cada u em vizinhança de v em G
            Se u.estado == 1
                Se v.custo + w({u, v}) < u.custo
                    u.pai = v
                    u.custo = v.custo + w({u, v})
            Senão, se u.estado == 0
                u.pai = v
                u.custo = v.custo + w({u, v})
                acrescente u a V
                u.estado = 1
        v.estado = 2
```

Complexidade: $\Theta(m.log(n))$. "Mesmo" algoritmo de Jarnik-Prim.

#### Corolário 68

G: grafo com n vértices e m arestas.

É possível computar em tempo $\Theta(n.m.log(n))$:

1. distâncias entre todos os pares de vértices de G.
2. diâmetro de G.

### Busca em Profundidade

```
BuscaProfundidade(G)
    Para cada v em V(G)
        v.estado = 0
    t = 0
    Para cada v em V(G)
        Se v.estado == 0
            v.pai = vazio
            BuscaProfundidade(G, v)
```

```
BuscaProfundidade(G, r)
    r.pre = ++t
    r.estado = 1
    Para cada v na vizinhança de r em G
        Se v.estado == 1 e v != r.pai
            processe {r, v}
        Senão, se v.estado == 0
            v.pai = r
            processe {r, v}
            BuscaProfundidade(G, v)
    processe r
    r.estado = 2
    r.pos = ++t
```

Seja F a floresta resultante da execução de BuscaProfundidade(G), então
1.  BuscaProfundidade(G, r) processa a árvore enraizada (T, r) e as arestas de
    G - F que ligam descendentes e ancestrais de r.
2.  v.pre é o **índice de pré-ordem** de v, que indice o "momento" de início do
    processamento da subárvore de T de raiz v ("DFS number").
3.  v.pos é o **índice de pós-ordem** de v, que indice o "momento" do fim do
    processamento da subárvore de T de raiz v.
4.  ao final, t = 2 * |V(G)|.

#### Teorema 69

Se F é a floresta resultante de uma busca em profundidade em um grafo G e u é
ancestral de v em F, então u.pre < v.pre < v.pos < u.pos.

Demonstração:

1.  Decorre da definição dos números de pré e pós ordem que u.pre < u.pos e
    v.pre < v.pos.
2.  Como u é ancestral de v em F, do Algoritmo BuscaProfundidade(G, r) temos
    que u.pre < v.pre e v.pos < u.pos.
3.  e daí, temos u.pre < v.pre < v.pos < u.pos.

#### Teorema 70

Se F é a floresta resultante de uma busca em profundidade de um grafo G, então
toda aresta em G - F é de retorno com relação a F.

### Buscas e Grafos Direcionados

Agora a busca é em grafos direcionados.

```
Busca(G)
    F = grafo direcionado vazio
    Para v em V(G)
        v.estado = 0
    Para v em V(G)
        Se v.estado == 0
            (T, v) = Busca(G, v)
            acrescente T a F
    Devolva F
```

```
Busca(G, r)
    V1 = vazio
    processe r
    r.pai = vazio
    acrescente r a V1
    r.estado = 1
    Enquanto V1 != vazio
        v = vértice em V1
        Se não há "próximo" vértice na vizinhança de saída de v em G
            retire v de V1
            v.estado = 2
        Senão
            w = "próximo" vértice na vizinhança de saída de v em G
            Se w.estado != 0
                Se (v, w) não foi processada
                    processe (v, w)
            Senão
                processe (v, w)
                processe w
                w.pai = v
                acrescente w a V1
                w.estado = 1
```

1.  A busca a partir do vértice v devolve uma arborescência de raiz v em vez de
    uma árvore enraizada em v.
2.  Pode devolver florestas direcionadas, mesmo quando o grafo é conexo.
3.  Pode haver arcos cruzados em uma floresta direcionada gerada por uma busca
    em profundidade.
4.  Se T é a árborescência resultante de uma busca no grafo direcionado G,
    então V[T] é o conjunto dos vértices de G alcançáveis a partir de v em G.

#### Corolário 71

O algoritmo Busca(G) devolve uma floresta direcionada geradora do grafo G e
processa todos os vértices e arcos de G. Além disso, o laço do Algoritmo
Busca(G, r) é executado $2 * |E(G)| + |V(G)|$ vezes.

#### Corolário 72

Se cada operação no laço do algoritmo Busca(G, r) é executada em tempo
$\Theta(1)$, então o tempo de execução do algoritmo Busca(G) é $\Theta(|E(G)| +
|V(G)|)$.

#### Pré-ordem e pós-ordem

Seja F uma floresta direcionada.

Uma **pré-ordem** de F é uma permutação de V(F) na qual ancestrais são
anteriores a seus descendentes.

Uma **pós-ordem** de F é uma permutação de V(F) na qual ancestrais são
posteriores a seus descendentes.

#### Teorema 73

F: floresta direcionada resultante de uma busca em profundidade sobre o grafo direcionado G.

v.pre e v.pos: índices de pré-ordem e pós-ordem computados.

O arco (u, v), com relação a F é:
1.  arco de F ou arco de avenço se, e somente se, `u.pre < v.pre < v.pos <
    u.pos`.
2.  arco cruzado se, e somente se, `v.pre < v.pos < u.pre < u.pos`.
3.  arco de retorno se, e somente se, `v.pre < u.pre < u.pos < v.pos`.

![Teorema 73](teorema73.png)

#### Ordem

A ordem < induzida sobre V(G) dada por:
1.  u < v := u.pre < v.pre - para todo u e v em V(G) - é uma pré-ordem de F.
2.  u < v := u.pos < v.pos - para todo u e v em V(G) - é uma pós-ordem de F.

#### Teorema 74

O grafo condensado de um grafo direcionado é acíclico.

![Teorema 74](teorema74.png)

#### Ordenação topológica

Dado um grafo direcionado G. Uma **ordenação topológica** de G é uma permutação
$(v_1, ..., v_n)$ de V(G) que "respeita a direção dos arcos" de G, isto é, $$i
< j, \forall (v_i, v_j) \in A(G)$$

![Ordenação topológica](ordenacao-topologica.png)

#### Teorema 75

Um grafo direcionado G admite ordenação topológico se, e somente se, é acíclico.

#### Teorema 76

Um grafo direcionado G é acíclico se, e somente se, qualquer floresta
direcionada resultante de uma busca em profundidade sobre G não tem arcos de
retorno.

#### Teorema 77

O reverso da pós-ordem de uma floresta direcionada resultante de uma busca em
profundiade em um grafo direcionado acíclico G é uma ordenação topológica de G.

Demonstração:
1.  Seja $(v_1, ..., v_n)$ a permutação de V(G) em ordem descrescente de
    pós-ordem, isto é, $i < j$ se, e somente se, $v_i.pos > v_j.pos$, para todo
    $1 \le i \lt j \le n \in A(G)$.
2.  Esta permutação é uma ordenação topológica de G. Basta provar que $i < j$
    para todo $(v_i, v_j) \in A(G)$, ou seja, que $v_i.pos > v_j.pos$ para todo
    $(v_i, v_j) \in A(G)$.
3.  Se tivéssemos $u.pos < v.pos$ então (u, v) seria arco de retorno em G (T. 73).
4.  Como G é acíclico, não tem arco de retorno (T. 76).
5.  Portanto, $v.pos < u.pos$ para todo $(u, v) \in A(G)$ e $(v_1, ..., v_n)$ é
    ordenação topológica de G.

#### Algoritmo de ordenação topológica

```
Ordena(G)
    Para cada v em V(G)
        v.estado = 0
    G.I = lista vazia
    Para cada v em V(G)
        Se v.estado == 0
            Ordena(G, v)
```

```
Ordena(G, r)
    r.estado = 1
    Para cada v na vizinhança de saída de r em G
        Se v.estado == 0
            Ordena(G, v)
    acrescente r ao início de G.I
    r.estado = 2
```

## Emparelhamento

TODO

## Algoritmo de Kruskal

TODO

## Planaridade

TODO

## Algoritmo de Teste de Planaridade

TODO

## Referências

* <https://www.youtube.com/watch?v=5qbNUmyC01s&list=PL-5ieW_feQNQeJpn0zmttgVbmUqGClG05&index=42>

## Veja também

* <https://www.inf.ufpr.br/murilo/ci1065/ci1065.html>
* <https://www.inf.ufpr.br/murilo/ci1065/slides/>
* <https://www.inf.ufpr.br/renato/ci1065/>

